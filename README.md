# robot-controller ðŸ¤–

Robot controller using concurrent programming practices made in Java.

## Project Goals
- Implement a concurrent programming approach for handling tasks performed by a robot.
- Employ safe concurrent programming practices
- Identify bottleneck found in one of the robot components
  
## How to run

1. navigate into the directory
2. `./build.sh`
3. `./run.sh`
  
## Overview

This robot controller simulator will divide the robot into 3 main components:
![42eb2c6d1f06038cb2defd23160eb1b5](https://github.com/ginesmoratalla/concurrent-robot-controller/assets/126341997/1d6a51cc-72a5-40ec-a76c-fb146f888515)

### Sensor
The sensor component generates tasks every second, where every task will have a **Task ID** and a **Task complexity** given by 0.1 $\leq c \leq 0.5$.
The number of tasks generated every second is determined by a Poisson distribution:

$P(k) = \frac{e^{-\lambda} \lambda^k}{k!}$

Where _k_ will be the number of tasks generated in 1 second (batch).

### Analyser
The analyser will collect tasks generated by the sensor, retrieved from a blocking queue (shared resource) and will "_analyse_" each task,
converting the task complexity to time
`thread.sleep(complexity)`

### Actuator
The actuator collects tasks analysed by the analyser, retrieved from a blocking queue (shared resource), and will "_process_" each task,
converting the task complexity into the distance to move the robot, given by the formula:

$\mathbb{Y} = \sqrt{\frac{1}{c}}$

The robot will move within the distance range [0, 1], and will bounce back when reaching the "walls" as long as it has any (instructed) moving distance left

![b4e8979964022b39aeb7b081ab9db539](https://github.com/ginesmoratalla/concurrent-robot-controller/assets/126341997/72c44547-77b4-4881-a5a7-1dd52f535ed4)

